#include "Phaser.hpp"
#include "standalone_helpers.hpp"

#define CATCH_CONFIG_MAIN
#include "catch.hpp"

// Some utilities to match the python
#include <math.h>
#include <vector>

typedef std::vector< float > flvec;

flvec sinbuf( float freq, int n )
{
  flvec result;
  for( int i=0; i<n; ++i )
    {
      float t = 1.0f * i / engineGetSampleRate();
      result.push_back( sin( t * 2 * M_PI * freq ) );
    }
  return result;
}

flvec sinbuf( float freq )
{
  int n = engineGetSampleRate() / 10;
  return sinbuf( freq, n );
}

float bufMag( flvec buf )
{
  float sumsq = 0;
  for( auto f : buf )
    sumsq += f * f;
  sumsq /= buf.size();
  return sqrt( sumsq ) / sqrt( 2.0f );
}

float rmsAtF( AllPassFilter &a, float freq )
{
  flvec sinb = sinbuf( freq );
  flvec res;
  for( auto f : sinb ) res.push_back( a.process( f ) + f );
  return bufMag( res );
}

float rmsAtF( float zR, float zI, float freq )
{
  AllPassFilter apf;
  apf.setComplex( zR, zI );
  return rmsAtF( apf, freq );
}


TEST_CASE( "All Pass Filter generates min per python" )
{
  // This code is generated by the pynb notebook
  CHECK( rmsAtF( 0.98, 0.04,  100 ) == Approx( 0.957165f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.98, 0.04,  200 ) == Approx( 0.742463f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.98, 0.04,  300 ) == Approx( 0.148971f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.98, 0.04,  400 ) == Approx( 0.479301f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.98, 0.04,  500 ) == Approx( 0.737406f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.850000, 0.100000, 940.000000 ) ==  Approx( 0.430219f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.100000, 0.850000, 10643.000000 ) ==  Approx( 0.368515f ).margin( 5e-5 ) );
  CHECK( rmsAtF( 0.931063, 0.188736, 1700.000000 ) ==  Approx( 0.543379f ).margin( 5e-5 ) );
}

flvec sqrBuf( float freq )
{
  int n = (int)(engineGetSampleRate() * 4 );
  // int n = 30;
  flvec res;
  for( int i=0; i<n; ++i )
    {
      float t = i * engineGetSampleTime();
      float s = sin( t * 2 * M_PI * freq );
      res.push_back( s > 0 ? 1 : -1 );
    }
  return res;
}

TEST_CASE( "Square Buffer gets phased" )
{
  CHECK( bufMag( sqrBuf( 220 ) ) == Approx( sqrt( 2 ) / 2 ) );

  flvec s220 = sqrBuf( 220 );
  flvec s4 = sqrBuf( 440 * pow( 2.0, 3.0/12.0 ) );
  flvec s7 = sqrBuf( 220 * pow( 2.0, 7.0 / 12.0 ) );

  flvec chord;
  for( int i=0; i<s220.size(); ++i )
    chord.push_back( ( s220[ i ] + s4[ i ] + s7[ i ] ) / 3 );

  CHECK( bufMag( chord ) == Approx( 0.408 ).margin( 1e-3 ) );

  flvec lfo = sinbuf( 1.0, chord.size() );
  std::transform( lfo.begin(), lfo.end(), lfo.begin(), []( float e ) -> float { return e * 0.47; } );

  Phaser ph;
  flvec phased;
  for( int i=0; i<chord.size(); ++i )
    phased.push_back( ph.process( chord[ i ], lfo[ i ] ) );

  CHECK( bufMag( phased ) == Approx( 0.315 ).margin( 1e-3 ) );
  // playBuffer( phased );
}
