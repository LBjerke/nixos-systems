
#include "LLPG.hpp"

void LLPG::Engine::reset() {
	trigger.reset();
}

void LLPG::Engine::setSampleRate(float sr) {
	finalHP.setParams(sr, MultimodeFilter::BUTTERWORTH_TYPE, 2, MultimodeFilter::HIGHPASS_MODE, 80.0f, MultimodeFilter::minQbw, MultimodeFilter::LINEAR_BANDWIDTH_MODE, MultimodeFilter::MINIMUM_DELAY_MODE);
}

void LLPG::reset() {
	for (int c = 0; c < _channels; ++c) {
		_engines[c]->reset();
	}
}

void LLPG::sampleRateChange() {
	_sampleRate = APP->engine->getSampleRate();
	_sampleTime = APP->engine->getSampleTime();
	for (int i = 0; i < _channels; ++i) {
		_engines[i]->setSampleRate(_sampleRate);
	}
}

bool LLPG::active() {
	return outputs[OUT_OUTPUT].isConnected();
}

int LLPG::channels() {
	return inputs[GATE_INPUT].getChannels();
}

void LLPG::addChannel(int c) {
	_engines[c] = new Engine();
	_engines[c]->reset();
	_engines[c]->setSampleRate(_sampleRate);
}

void LLPG::removeChannel(int c) {
	delete _engines[c];
	_engines[c] = NULL;
}

void LLPG::modulateChannel(int c) {
	_engines[c]->slew.modulate(
		_sampleRate,
		params[RESPONSE_PARAM],
		NULL,
		100.0f,
		params[SHAPE_PARAM],
		params[RESPONSE_PARAM],
		NULL,
		2000.0f,
		params[SHAPE_PARAM],
		c,
		true
	);
}

void LLPG::processChannel(const ProcessArgs& args, int c) {
	Engine& e = *_engines[c];

	if (e.trigger.process(inputs[GATE_INPUT].getPolyVoltage(c))) {
		float time = clamp(params[RESPONSE_PARAM].getValue(), 0.0f, 1.0f);
		time *= time;
		time *= 0.1f;
		time += 0.01f;
		e.gateSeconds = time;

		e.gateElapsedSeconds = 0.0f;
		e.gateSeconds = time;
	}
	else {
		e.gateElapsedSeconds += _sampleTime;
	}

	float gate = 0.0f;
	if (e.gateElapsedSeconds < e.gateSeconds) {
		gate = 10.0f;
	}
	float env = e.slew.next(gate);
	env /= 10.0f;

	float lpfBias = clamp(params[LPF_PARAM].getValue(), -1.0f, 1.0f);
	lpfBias *= lpfBias;
	float f = clamp(lpfBias + env, 0.0f, 1.0f);
	f *= maxFilterCutoff;
	f = std::max(f, MultimodeFilter4::minFrequency);
	e.lpf.setParams(
		_sampleRate,
		MultimodeFilter::BUTTERWORTH_TYPE,
		2,
		MultimodeFilter::LOWPASS_MODE,
		f,
		0.0f
	);

	float vcaBias = clamp(params[VCA_PARAM].getValue(), 0.0f, 1.0f);
	float level = clamp(vcaBias + env, 0.0f, 1.0f);

	float out = inputs[IN_INPUT].getPolyVoltage(c);
	out = e.finalHP.next(e.lpf.next(out));
	e.vca.setLevel(Amplifier::minDecibels * (1.0f - level));
	out = e.vca.next(out);
	outputs[OUT_OUTPUT].setChannels(_channels);
	outputs[OUT_OUTPUT].setVoltage(out, c);
}

struct LLPGWidget : BGModuleWidget {
	static constexpr int hp = 3;

	LLPGWidget(LLPG* module) {
		setModule(module);
		box.size = Vec(RACK_GRID_WIDTH * hp, RACK_GRID_HEIGHT);
		setPanel(box.size, "LLPG");
		createScrews();

		// generated by svg_widgets.rb
		auto responseParamPosition = Vec(8.0, 36.5);
		auto shapeParamPosition = Vec(14.5, 82.0);
		auto lpfParamPosition = Vec(9.5, 130.0);
		auto vcaParamPosition = Vec(9.5, 185.0);

		auto gateInputPosition = Vec(10.5, 228.0);
		auto inInputPosition = Vec(10.5, 263.0);

		auto outOutputPosition = Vec(10.5, 301.0);
		// end generated by svg_widgets.rb

		addParam(createParam<Knob26>(responseParamPosition, module, LLPG::RESPONSE_PARAM));
		addParam(createParam<Knob16>(shapeParamPosition, module, LLPG::SHAPE_PARAM));
		addParam(createParam<Knob26>(lpfParamPosition, module, LLPG::LPF_PARAM));
		addParam(createParam<Knob26>(vcaParamPosition, module, LLPG::VCA_PARAM));

		addInput(createInput<Port24>(gateInputPosition, module, LLPG::GATE_INPUT));
		addInput(createInput<Port24>(inInputPosition, module, LLPG::IN_INPUT));

		addOutput(createOutput<Port24>(outOutputPosition, module, LLPG::OUT_OUTPUT));
	}
};

Model* modelLLPG = createModel<LLPG, LLPGWidget>("Bogaudio-LLPG", "LLPG", "Low-pass gate", "Low-pass gate", "Polyphonic");
