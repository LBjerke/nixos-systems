/*
 * DISTRHO Cardinal Plugin
 * Copyright (C) 2021-2022 Filipe Coelho <falktx@falktx.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 3 of
 * the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * For a full copy of the GNU General Public License see the LICENSE file.
 */

#pragma once

#include "rack.hpp"

#ifdef NDEBUG
# undef DEBUG
#endif

using namespace rack;

#ifndef HEADLESS
struct CardinalLedDisplayChoice : LedDisplayChoice {
    bool alignTextCenter = true;

    CardinalLedDisplayChoice(const char* const label = nullptr)
    {
        color = nvgRGBf(0.76f, 0.11f, 0.22f);
        textOffset.y -= 4;

        if (label != nullptr)
            text = label;
    }

    void drawLayer(const DrawArgs& args, const int layer) override
    {
        if (layer == 1)
        {
            nvgFillColor(args.vg, color);
            nvgTextLetterSpacing(args.vg, 0.0f);

            if (alignTextCenter)
            {
                nvgTextAlign(args.vg, NVG_ALIGN_CENTER);
                nvgText(args.vg, box.size.x * 0.5f, textOffset.y, text.c_str(), nullptr);
            }
            else
            {
                nvgTextAlign(args.vg, NVG_ALIGN_LEFT);
                nvgText(args.vg, textOffset.x, textOffset.y, text.c_str(), nullptr);
            }
        }

        Widget::drawLayer(args, layer);
    }
};

struct OpenGlWidgetWithBrowserPreview : OpenGlWidget {
    NVGLUframebuffer* fb = nullptr;

    void draw(const DrawArgs& args) override
    {
        if (args.fb == nullptr)
            return OpenGlWidget::draw(args);

        // set oversample to current scale
        float trans[6];
        nvgCurrentTransform(args.vg, trans);
        oversample = std::max(1.0f, trans[0]);

        // recreate framebuffer
        deleteFramebuffer();
        fb = nvgluCreateFramebuffer(args.vg, box.size.x * oversample, box.size.y * oversample, 0);
        DISTRHO_SAFE_ASSERT_RETURN(fb != nullptr,);

        // draw our special framebuffer
        nvgluBindFramebuffer(fb);
        drawFramebufferForBrowserPreview();

        // reset to regular framebuffer
        nvgluBindFramebuffer(args.fb);

        // render image generated by our framebuffer
        nvgBeginPath(args.vg);
        nvgRect(args.vg, 0.0f, 0.0f, box.size.x, box.size.y);
        NVGpaint paint = nvgImagePattern(args.vg,
                                          0.0f, 0.0f, box.size.x, box.size.y,
                                          0.0f, fb->image, 1.0f);
        nvgFillPaint(args.vg, paint);
        nvgFill(args.vg);
    }

    void onContextDestroy(const ContextDestroyEvent& e) override
    {
        deleteFramebuffer();
        OpenGlWidget::onContextDestroy(e);
    }

    void deleteFramebuffer()
    {
        if (fb == nullptr)
            return;
        nvgluDeleteFramebuffer(fb);
        fb = nullptr;
    }

    virtual void drawFramebufferForBrowserPreview() = 0;
};
#endif

extern Plugin* pluginInstance;

extern Model* modelAudioFile;
extern Model* modelCarla;
extern Model* modelCardinalBlank;
extern Model* modelGlBars;
extern Model* modelHostAudio2;
extern Model* modelHostAudio8;
extern Model* modelHostCV;
extern Model* modelHostMIDI;
extern Model* modelHostMIDICC;
extern Model* modelHostMIDIGate;
extern Model* modelHostMIDIMap;
extern Model* modelHostParameters;
extern Model* modelHostTime;
extern Model* modelIldaeil;
extern Model* modelMPV;
extern Model* modelTextEditor;
